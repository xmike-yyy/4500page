<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Design Decisions Writeup</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <header>
    <h1>Key Design Decisions in Prototype</h1>
  </header>

  <section>
    <p>This writeup explains how the current code (in <code>index.html</code> and <code>index.js</code>) implements core functionality and the reasoning behind object structures.</p>
    <ul>
  <li><strong>Message Objects:</strong> Sending a chat message uses:
    <pre>{
  value: { content: &lt;text&gt;, published: &lt;timestamp&gt; },
  channels: [&lt;channelId&gt;]
}</pre>
    A JSON schema enforces required <code>content</code> and <code>published</code> fields.</li>
  <li><strong>Tagging Objects:</strong> Tag data includes metadata:
    <pre>{
  activity: "Tag",
  target: &lt;messageId&gt;,
  tag: &lt;tagName&gt;,
  content: &lt;messageContent&gt;,
  conversationName: &lt;conversationName&gt;,
  channelId: &lt;channelId&gt;,
  published: &lt;timestamp&gt;
}</pre>
    Storing <code>content</code> and <code>conversationName</code> simplifies later display without additional lookups.</li>
  
    <li><strong>Search Tagged Messages:</strong> A sidebar filter lets me search and filter tags by name or keyword, refining results from the <code>designftw</code> channel in real time.
    </li>
  
    <li><strong>Direct vs. Group Chats:</strong> I haven’t decided whether to restrict the app to direct messages only or support group chats. I also need a mechanism to discover users on the network and add them by unique user ID (rather than by name) to ensure accurate identification.
    </li>
  
    <li><strong>Session Persistence:</strong> I store <code>sessionTags</code> in <code>localStorage</code> so tag assignments persist across page reloads.
    </li>
  
    <li><strong>UI Feedback & Structure:</strong> Two main views—“Inbox” and “Tagged”—are toggled by a <code>view</code> state. Clear headers, loading indicators, disabled button states, and tooltips provide async feedback.
    </li>
  
    <li><strong>Offline Fallback:</strong> I seed initial content with <code>fakeMessages</code> when live data is delayed, ensuring a seamless conversation experience.
    </li>
</ul>
  </section>
</body>
</html>
